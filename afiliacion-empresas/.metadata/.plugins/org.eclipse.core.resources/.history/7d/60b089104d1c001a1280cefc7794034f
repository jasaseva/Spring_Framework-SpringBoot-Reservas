/*
 * PropertiesManager.java
 *
 * Creada el 16 de abril de 2007, 02:59 PM
 *
 */
package co.com.quipux.transversal;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import co.com.quipux.transversal.utilidades.model.UsuarioAuditoria;

/**
 * Esta clase administra la informacion contenida en los properties. Pone a disposicion la funcionalidad de consultar de un properties por una clave
 * especifica sin que el archivo tenga que ser cargado una y otra vez en los diferentes metodos de la aplicacion (como generalmente se hac�a con los
 * DAO).
 * 
 * @author Quipux S.A.
 * @modify 16/04/2007
 * @modify 28/04/2014
 * @modify 29/07/2014
 */
public class PropertiesManager {

	private static Logger logger = LoggerFactory.getLogger(PropertiesManager.class);
	/**
	 * HashMap para almacenar los archivos, usando como llave el nombre del archivo
	 */
	private static Map<String, Properties> table = new HashMap<>();
	public static String ambiente;

	private static final String DESARROLLO = "DESARROLLO";

	/**
	 * Permite en la etapa de desarrollo hacer cambios de forma dinamica en los archivos *sql.properties, si la propiedad server.ambiente no esta
	 * configurada en el casconfig.properties este toma un valor PRODUCCION por defecto<br>
	 * Creado el 6/04/2016 a las 3:31:27 p. m. <br>
	 * 
	 * @author <a href="http://www.quipux.com/">Quipux Software.</a></br>
	 */
	private static void cargarAmbiente() {
		ambiente = obtenerServidorAplicaciones("/opt/qits/casconfig.properties", "server.ambiente");
		if (!DESARROLLO.equals(ambiente)) {
			ambiente = "PRODUCCION";
		}
	}

	/**
	 * Permite clasificar un sql deacuerdo a si se debe ejecutar en una base de datos cuya estructura contempla el uso de esquemas en cada entidad de
	 * tr�nsito.
	 * 
	 * @param sql
	 * @param idOrganismoTransito
	 * @return String
	 */
	private static String filtrarSql(String sql, String idOrganismoTransito) {
		String sqlFiltrado;
		if (idOrganismoTransito != null && !"".equals(idOrganismoTransito.trim())) {
			sqlFiltrado = sql.replaceAll("<SCHEMA>", idOrganismoTransito);
		} else {
			sqlFiltrado = sql.replaceAll("_<SCHEMA>", "");
		}
		return sqlFiltrado;
	}

	/**
	 * Creado el Sep 15, 2016 a las 6:57:34 AM <br>
	 * 
	 * @param loader
	 * @param nombreArchivo
	 * @return
	 * @throws IOException
	 */
	private static Properties loadProperties(ClassLoader loader, String nombreArchivo) throws IOException {
		Properties properties = null;
		InputStream inputStream = null;
		try {
			inputStream = loader.getResourceAsStream(nombreArchivo);
			if (inputStream == null) {
				return null;
			}
			properties = new Properties();
			// load a properties file from class path, inside static method
			properties.load(inputStream);
		} catch (IOException ex) {
			throw new IOException(ex.getMessage(), ex);
		} finally {
			if (inputStream != null) {
				try {
					inputStream.close();
				} catch (IOException e) {
					throw new IOException(e.getMessage(), e);
				}
			}
		}
		return properties;
	}

	/**
	 * Creado el Sep 15, 2016 a las 6:57:46 AM <br>
	 * 
	 * @param nombreArchivo
	 * @return
	 * @throws IOException
	 */
	private static Properties loadPropertiesFile(String nombreArchivo) throws IOException {
		FileInputStream fileInputStream = null;
		Properties properties = null;
		try {
			fileInputStream = new FileInputStream(nombreArchivo.replace("%20", " "));
			properties = new Properties();
			properties.load(fileInputStream);
		} catch (IOException e) {
			throw new IOException(e.getMessage(), e);
		} finally {
			if (fileInputStream != null) {
				try {
					fileInputStream.close();
				} catch (IOException e) {
					throw new IOException(e.getMessage(), e);
				}
			}
		}
		return properties;
	}

	/**
	 * Este metodo recibe un nombre de archivo y una cadena clave. Del archivo especificado retorna el valor que corresponde a la cadena.
	 * 
	 * @param loader
	 *            Permite cargar los properties desde el classloader
	 * 
	 * @param nombreArchivo
	 *            Nombre del archivo del que se obtendra la informacion
	 * @param nombreClave
	 *            Clave que sera usada para identifica la cadena
	 * @return Retorna un string con la cadena correspondiente.
	 * @throws IOException
	 */
	public static String obtenerCadena(ClassLoader loader, String nombreArchivo, String nombreClave) {
		UsuarioAuditoria user = QxAuditHolder.get();
		// Intento obtener el archivo del hashtable
		Properties properties = table.get(nombreArchivo);
		try {
			// Si no logra obtener el archivo de la tabla, entonces lo cargo
			if (properties == null || DESARROLLO.equals(ambiente)) {
				properties = loadProperties(loader, nombreArchivo);
				table.put(nombreArchivo, properties);
				cargarAmbiente();
			}
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}

		// Retorno el string asociado a la cadena especificada
		if (user != null) {
			return filtrarSql(properties.getProperty(nombreClave), user.getSchema());
		}
		return properties.getProperty(nombreClave);
	}

	/**
	 * Este metodo recibe un nombre de archivo y una cadena clave. Del archivo especificado retorna el valor que corresponde a la cadena.
	 * 
	 * @param nombreArchivo
	 *            Nombre del archivo del que se obtendra la informacion
	 * @param nombreClave
	 *            Clave que sera usada para identifica la cadena
	 * @return Retorna un string con la cadena correspondiente.
	 */
	public static String obtenerCadena(ClassLoader loader, String nombreArchivo, String nombreClave, Object[] varArgs) {
		// Intento obtener el archivo del hashtable
		Properties properties = table.get(nombreArchivo);
		try {
			// Si no logr� obtener el archivo de la tabla, entonces lo cargo
			if (properties == null || DESARROLLO.equals(ambiente)) {
				properties = loadProperties(loader, nombreArchivo);
				table.put(nombreArchivo, properties);
				cargarAmbiente();
			}
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}
		// Retorno el string asociado a la cadena especificada
		return reemplazarParametros(properties.getProperty(nombreClave), varArgs);
	}

	/**
	 * Este metodo recibe un nombre de archivo, una cadena clave y nombre de schema. Del archivo especificado retorna el valor que corresponde a la
	 * cadena.
	 * 
	 * @param nombreArchivo
	 *            Nombre del archivo del que se obtendra la informacion
	 * @param nombreClave
	 *            Clave que sera usada para identifica la cadena
	 * @return Retorna un string con la cadena correspondiente.
	 */
	public static String obtenerCadena(ClassLoader loader, String nombreArchivo, String nombreClave, String schema) {
		// Intento obtener el archivo del hashtable
		Properties properties = table.get(nombreArchivo);
		try {
			// Si no logr� obtener el archivo de la tabla, entonces lo cargo
			if (properties == null || DESARROLLO.equals(ambiente)) {
				properties = loadProperties(loader, nombreArchivo);
				table.put(nombreArchivo, properties);
				cargarAmbiente();
			}
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		}

		// Retorno el string asociado a la cadena especificada
		return filtrarSql(properties.getProperty(nombreClave), schema);
	}

	/**
	 * Obtiene una propiedad de un archivo almacenado en disco
	 * 
	 * @param urlFile
	 * @param nombreClave
	 * @return
	 */
	public static String obtenerCadenaExterna(String urlFile, String nombreClave) {
		String propertie = "";
		// Intento obtener el archivo del hashtable
		Properties properties = table.get(urlFile);
		// Si no logr� obtener el archivo de la tabla, entonces lo cargo
		try {
			if (properties == null || DESARROLLO.equals(ambiente)) {
				properties = loadPropertiesFile(urlFile);
				table.put(urlFile, properties);
			}
			// Retorno el string asociado a la cadena especificada
			if (properties.containsKey(nombreClave)) {
				propertie = properties.getProperty(nombreClave);
			} else {
				propertie = "Propiedad " + nombreClave + " no encontrada en " + urlFile;
			}
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			return "Propiedad " + nombreClave + " no encontrada en " + urlFile;
		}
		return propertie;
	}

	/**
	 * Obtiene el schema del usuario en sesion y lo concatena al string
	 * 
	 * @param sql
	 * @return
	 */
	public static String obtenerSchema(String sql) {
		UsuarioAuditoria user = QxAuditHolder.get();

		// Retorno el string asociado a la cadena especificada
		if (user != null) {
			return filtrarSql(sql, user.getSchema());
		}
		return sql;
	}

	/**
	 * Obtiene una propiedad de un archivo almacenado en disco con la ruta relativa del domain de glassfish
	 * 
	 * @param urlFile
	 * @param nombreClave
	 * @return
	 */
	public static String obtenerServidorAplicaciones(String relativeFile, String nombreClave) {
		String path = ServerDetector.getServerPath();
		String urlFile = path + relativeFile;
		return obtenerCadenaExterna(urlFile, nombreClave);
	}

	/**
	 * Metodo que toma una cadena y un array de parametros y reemplaza los valores
	 * 
	 * @param cadena
	 * @param varArgs
	 * @return
	 */
	private static String reemplazarParametros(String cadena, Object[] varArgs) {
		String valorParametro = cadena;
		for (int i = 0; i < varArgs.length; i++) {
			valorParametro = valorParametro.replace("{" + i + "}", "" + varArgs[i]);
		}
		return valorParametro;
	}
}